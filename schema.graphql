type OptionFactory @entity {
  # factory address
  id: ID!

  # factory info
  optionCount: Int!
  marketCount: Int!

  # transactions
  txCount: BigInt!

  # one-to-many relationships using reverse lookup
  options: [Option!]! @derivedFrom(field: "factory")
  markets: [Market!]! @derivedFrom(field: "factory")
}

type Market @entity {
  # underlyingToken + "-" + strikeToken
  id: ID!

  # stats
  totalStrikeLocked: BigDecimal!
  totalUnderlyingLocked: BigDecimal!
  strikeTotalVolume: BigDecimal!
  underlyingTotalVolume: BigDecimal!
  txCount: BigInt!

  # for reverse lookup
  factory: OptionFactory!

  # one-to-many relationships using reverse lookup
  options: [Option!]! @derivedFrom(field: "market")
}

type Option @entity {
  # pair address
  id: ID!

  # option info
  expiry: Int!
  underlyingToken: Token!
  strikeToken: Token!
  shortToken: Token! # redeem token
  #
  # stats
  strikeLocked: BigDecimal!
  underlyingLocked: BigDecimal!
  strikeVolume: BigDecimal!
  underlyingVolume: BigDecimal!

  # for reverse lookup
  factory: OptionFactory!
  market: Market!

  # one-to-one relationship
  uniswapPair: UniswapPair
}

type Token @entity {
  # token address
  id: ID!

  # mirrored from the smart contract
  symbol: String!
  name: String!
  decimals: BigInt!

  # extra info needed for other parts of subgraph
  kind: TokenKind!
}

enum TokenKind {
  OPTION # long token
  REDEEM # short token
  OTHER
}

type UniswapPair @entity {
  # uniswap pair address
  id: ID!

  # one-to-one
  option: Option!

  # tokens
  shortToken: Token! # redeem token
  underlyingToken: Token!

  # uniswap reserves
  shortReserve: BigDecimal!
  underlyingReserve: BigDecimal!

  # not sure
  # longDepth: BigDecimal!

  # stats
  shortVolume: BigDecimal!
  underlyingVolume: BigDecimal!
  txCount: BigInt!
  liquidityProviderCount: BigInt!

  # details
  createdAtTimestamp: Int!
  createdAtBlockNumber: BigInt!
}
