type OptionFactory @entity {
  # factory address
  id: ID!

  # factory info
  optionCount: Int!
  marketCount: Int!

  # transactions
  txCount: BigInt!

  # one-to-many relationships using reverse lookup
  markets: [Market!]! @derivedFrom(field: "factory")
  options: [Option!]! @derivedFrom(field: "factory")
  transactions: [Transaction!]! @derivedFrom(field: "factory")
}

type Market @entity {
  # underlyingToken + "-" + strikeToken
  id: ID!

  # stats
  totalStrikeLocked: BigDecimal!
  totalUnderlyingLocked: BigDecimal!
  strikeTotalVolume: BigDecimal!
  underlyingTotalVolume: BigDecimal!
  txCount: BigInt!

  # for reverse lookup
  factory: OptionFactory!

  # one-to-many relationships using reverse lookup
  options: [Option!]! @derivedFrom(field: "market")
  transactions: [Transaction!]! @derivedFrom(field: "market")
}

type Option @entity {
  # pair address
  id: ID!

  # option info
  expiry: Int!
  underlyingToken: Token!
  strikeToken: Token!
  shortToken: Token! # redeem token
  #
  # stats
  strikeLocked: BigDecimal!
  underlyingLocked: BigDecimal!
  strikeVolume: BigDecimal!
  underlyingVolume: BigDecimal!

  # for reverse lookup
  factory: OptionFactory!
  market: Market!

  # one-to-one relationship
  uniswapPair: UniswapPair

  # one-to-many relationships using reverse lookup
  optionPositions: [OptionPosition!]! @derivedFrom(field: "option")
  transactions: [Transaction!]! @derivedFrom(field: "option")
}

type Token @entity {
  # token address
  id: ID!

  # mirrored from the smart contract
  symbol: String!
  name: String!
  decimals: BigInt!

  # extra info needed for other parts of subgraph
  kind: TokenKind!

  # one-to-many relationships using reverse lookup
  tokenBalances: [TokenBalance]! @derivedFrom(field: "token")
}

enum TokenKind {
  OPTION # long token
  REDEEM # short token
  OTHER
}

type TokenBalance @entity {
  # token address + '-' + user address
  id: ID!

  balance: BigDecimal!

  # for reverse lookup
  token: Token!
  user: User!
}

type UniswapPair @entity {
  # uniswap pair address
  id: ID!

  # one-to-one
  option: Option!

  # tokens
  shortToken: Token! # redeem token
  underlyingToken: Token!

  # uniswap reserves
  shortReserve: BigDecimal!
  underlyingReserve: BigDecimal!

  # not sure
  # longDepth: BigDecimal!

  # stats
  shortVolume: BigDecimal!
  underlyingVolume: BigDecimal!
  txCount: BigInt!
  liquidityProviderCount: BigInt!

  # details
  createdAtTimestamp: Int!
  createdAtBlockNumber: BigInt!

  # one-to-many relationships using reverse lookup
  optionPositions: [OptionPosition!]! @derivedFrom(field: "uniswapPair")
  liquidityPositions: [LiquidityPosition!]! @derivedFrom(field: "uniswapPair")
}

type Transaction @entity {
  # transaction hash
  id: ID!

  blockNumber: BigInt!
  timestamp: BigInt!
  orderType: OrderType!
  internalOrders: [OrderType!]!

  # for reverse lookup
  factory: OptionFactory!
  market: Market!
  option: Option!
  user: User # this is set if tx is to uniswap connector contract
}

enum OrderType {
  MINT
  EXERCISE
  REDEEM
  CLOSE
  UNWIND
  LONG
  SHORT
  WRITE
  CLOSE_LONG
  CLOSE_SHORT
  NEUTRAL
  ADD_LIQUIDITY
  ADD_LIQUIDITY_CUSTOM
  REMOVE_LIQUIDITY
  REMOVE_LIQUIDITY_CLOSE
  NEW_MARKET
  NONE
  APPROVE
}

type User @entity {
  # user address
  id: ID!

  # one-to-many relationships using reverse lookup
  optionPositions: [OptionPosition!]! @derivedFrom(field: "user")
  liquidityPositions: [LiquidityPosition!]! @derivedFrom(field: "user")
  transactions: [Transaction!]! @derivedFrom(field: "user")
  tokenBalances: [TokenBalance]! @derivedFrom(field: "user")
}

type LiquidityPosition @entity {
  # pair address + '-' + user address
  id: ID!

  liquidityTokenBalance: BigDecimal!

  # for reverse lookup
  option: Option!
  uniswapPair: UniswapPair!
  user: User!
}

type OptionPosition @entity {
  # pair address + '-' + user address
  id: ID!

  positionType: OrderType!
  longBalance: BigDecimal!
  shortBalance: BigDecimal!

  # for reverse lookup
  option: Option!
  uniswapPair: UniswapPair!
  user: User!
}
